void path_manager_example::manage_dubins(const params_s &params, const input_s &input, output_s &output)
{
    Eigen::Vector3f p;
    p(0) = input.pn;
    p(1) = input.pe;
    p(2) = -input.h;
    float R_min = params.R_min;
    switch(_dub_state)
    {
    case dubin_state::First:
        dubinsParameters(_waypoints[0], _waypoints[1], R_min);
        output.flag = false;
        output.Va_d = _ptr_a->Va_d;
        output.r[0] = 0;
        output.r[1] = 0;
        output.r[2] = 0;
        output.q[0] = 0;
        output.q[1] = 0;
        output.q[2] = 0;
        output.c[0] = _dubinspath.cs(0);
        output.c[1] = _dubinspath.cs(1);
        output.c[2] = _dubinspath.cs(2);
        output.rho = _dubinspath.R;
        output.lambda = _dubinspath.lams;
        if(dot(p - _dubinspath.w1, _dubinspath.q1) >= 0) // start in H1
            _dub_state = dubin_state::Before_H1_wrong_side;
        else
            _dub_state = dubin_state::Before_H1;
        break;
    case dubin_state::Before_H1:
        output.flag = false;
        output.Va_d = _ptr_a->Va_d;
        output.r[0] = 0;
        output.r[1] = 0;
        output.r[2] = 0;
        output.q[0] = 0;
        output.q[1] = 0;
        output.q[2] = 0;
        output.c[0] = _dubinspath.cs(0);
        output.c[1] = _dubinspath.cs(1);
        output.c[2] = _dubinspath.cs(2);
        output.rho = _dubinspath.R;
        output.lambda = _dubinspath.lams;
        if(dot(p - _dubinspath.w1, _dubinspath.q1) >= 0) // entering H1
            _dub_state = dubin_state::Straight;
        break;
    case dubin_state::Before_H1_wrong_side:
        output.flag = false;
        output.Va_d = _ptr_a->Va_d;
        output.r[0] = 0;
        output.r[1] = 0;
        output.r[2] = 0;
        output.q[0] = 0;
        output.q[1] = 0;
        output.q[2] = 0;
        output.c[0] = _dubinspath.cs(0);
        output.c[1] = _dubinspath.cs(1);
        output.c[2] = _dubinspath.cs(2);
        output.rho = _dubinspath.R;
        output.lambda = _dubinspath.lams;
        if(dot(p - _dubinspath.w1, _dubinspath.q1) < 0) // exit H1
            _dub_state = dubin_state::Before_H1;
        break;
    case dubin_state::Straight:
        output.flag = true;
        output.Va_d = _ptr_a->Va_d;
        output.r[0] = _dubinspath.w1(0);
        output.r[1] = _dubinspath.w1(1);
        output.r[2] = _dubinspath.w1(2);
        output.q[0] = _dubinspath.q1(0);
        output.q[1] = _dubinspath.q1(1);
        output.q[2] = _dubinspath.q1(2);
        output.c[0] = 1;
        output.c[1] = 1;
        output.c[2] = 1;
        output.rho = 1;
        output.lambda = 1;
        if(dot(p - _dubinspath.w2, _dubinspath.q1) >= 0) // entering H2
        {
            if(dot(p - _dubinspath.w3, _dubinspath.q3) >= 0) // start in H3
                _dub_state = dubin_state::Before_H3_wrong_side;
            else
                _dub_state = dubin_state::Before_H3;
        }
        break;
    case dubin_state::Before_H3:
        output.flag = false;
        output.Va_d = _ptr_a->Va_d;
        output.r[0] = 0;
        output.r[1] = 0;
        output.r[2] = 0;
        output.q[0] = 0;
        output.q[1] = 0;
        output.q[2] = 0;
        output.c[0] = _dubinspath.ce(0);
        output.c[1] = _dubinspath.ce(1);
        output.c[2] = _dubinspath.ce(2);
        output.rho = _dubinspath.R;
        output.lambda = _dubinspath.lame;
        if(dot(p - _dubinspath.w3, _dubinspath.q3) >= 0) // entering H3
        {
            // increase the waypoint pointer
            waypoint_s* ptr_b;
            if(_ptr_a == &_waypoints[_num_waypoints - 1])
            {
                _ptr_a = &_waypoints[0];
                ptr_b = &_waypoints[1];
            } else if(_ptr_a == &_waypoints[_num_waypoints - 2])
            {
                _ptr_a++;
                ptr_b = &_waypoints[0];
            } else
            {
                _ptr_a++;
                ptr_b = _ptr_a + 1;
            }

            // plan new Dubin's path to next waypoint configuration
            dubinsParameters(*_ptr_a, *ptr_b, R_min);

            //start new path
            if(dot(p - _dubinspath.w1, _dubinspath.q1) >= 0) // start in H1
                _dub_state = dubin_state::Before_H1_wrong_side;
            else
                _dub_state = dubin_state::Before_H1;
        }
        break;
    case dubin_state::Before_H3_wrong_side:
        output.flag = false;
        output.Va_d = _ptr_a->Va_d;
        output.r[0] = 0;
        output.r[1] = 0;
        output.r[2] = 0;
        output.q[0] = 0;
        output.q[1] = 0;
        output.q[2] = 0;
        output.c[0] = _dubinspath.ce(0);
        output.c[1] = _dubinspath.ce(1);
        output.c[2] = _dubinspath.ce(2);
        output.rho = _dubinspath.R;
        output.lambda = _dubinspath.lame;
        if(dot(p - _dubinspath.w3, _dubinspath.q3) < 0) // exit H3
            _dub_state = dubin_state::Before_H1;
        break;
    }
}
